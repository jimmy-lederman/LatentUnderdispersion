---
title: "Untitled"
output: html_document
date: "2026-01-21"
---



```{r}
library(brms)
library(COMPoissonReg)
```

```{r}
#load in masks
mask1 <- as.matrix(read.csv("/Users/jimmy/Desktop/OrderStats/models/flights_final/revisionmasks/mask_1.csv"))[,1]
```




```{r}
datafile = "/Users/jimmy/Desktop/OrderStats/data/flights_data/flights_final.csv"
df <- read.csv(datafile)
y <- df$AIR_TIME
home_N <- df$origin
away_N <- df$dest

routes_R4 <- list()
airports <- 99
for (t1 in 1:airports) {
  for (t2 in 1:airports) {
    bitvector <- (home_N == t1) & (away_N == t2)

    if (sum(bitvector) != 0) {
      indices <- which(bitvector)

      routes_R4[[length(routes_R4) + 1]] <-
        list(t1, t2)
    }
  }
}

routes_R4 <- do.call(rbind, lapply(routes_R4, function(x) {
  data.frame(
    t1 = x[[1]],
    t2 = x[[2]]
  )
}))
routes_R4$route <- 1:nrow(routes_R4)

routes <- with(
  df,
  routes_R4$route[
    match(
      paste(origin, dest),
      paste(routes_R4$t1, routes_R4$t2)
    )
  ]
)
df$route <- as.factor(routes)
```

```{r}
nsub <- 584
dftrain <- df[mask1 == 0, ]
dftest <- df[mask1 == 1,]
set.seed(123)   # optional, for reproducibility
required_routes <- unique(df$route)
train_required <- dftrain[dftrain$route %in% required_routes, ]
forced_rows <- do.call(
  rbind,
  lapply(split(train_required, train_required$route), function(x) x[sample(nrow(x), 1), ])
)
stopifnot(length(setdiff(required_routes, unique(dftrain$route))) == 0)
remaining_n <- nsub - nrow(forced_rows)

remaining_pool <- dftrain[!(rownames(dftrain) %in% rownames(forced_rows)), ]

random_rows <- remaining_pool[sample(nrow(remaining_pool), remaining_n), ]

dftrain_subset <- rbind(forced_rows, random_rows)
```



```{r}
model <- brm(
  AIR_TIME ~ route,
  data = dftrain_subset,
  family = brmsfamily("com_poisson", link = "log"),
  chains = 1,
  iter = 1500,
  warmup = 1000
)
```



```{r}
library(brms)
set.seed(123)

# Simulate data
n <- 50
df <- data.frame(
  route = factor(sample(c("A-B", "B-C"), n, replace = TRUE))
)

# True parameters
beta0 <- 5       # intercept (log scale)
beta1 <- 0.5     # effect of route "B-C"
nu <- 1          # dispersion (Poisson-like)

# Linear predictor
eta <- beta0 + beta1 * (df$route == "B-C")

# Lambda for COM-Poisson
lambda <- exp(eta)

# Simulate AIR_TIME from COM-Poisson (approximate via rpois for demo)
# brms will handle COM-Poisson properly; we just simulate something reasonable
df$AIR_TIME <- rpois(n, lambda)

# Fit COM-Poisson model
fit <- brm(
  AIR_TIME ~ route,
  data = df,
  family =  brmsfamily("com_poisson", link = "log"),
  chains = 2,
  iter = 500,
  warmup = 250
)
# 
# # Inspect coefficients
# summary(fit)
# 
# # Fitted values (posterior mean)
# fitted(fit)
# 
# # Posterior predictive draws
# yhat <- posterior_predict(fit)
# head(yhat)

```

```{r}
posterior <- as.data.frame(fit)
draw <- as.numeric(posterior[500,])
mu <- draw[1] + draw[2]
shape <- draw[3]
```



```{r}
setwd("/Users/jimmy/Desktop/OrderStats/models/flights_final/combayes-master")
install.packages(".", repos = NULL, type = "source")
library(combayes)

```
```{r}
hist(rcmpois(mu=exp(mu-1),nu=shape,n=100))
```


delta_candidate <- par_candidate[2]  # scalar
log_u <- log(runif(1)) +
mvnfast::dmvn(beta_current, mu=prior_mean_beta, sigma=prior_var_beta, log=TRUE) -
mvnfast::dmvn(beta_candidate, mu=prior_mean_beta, sigma=prior_var_beta, log=TRUE) +
dnorm(delta_current, mean=prior_mean_delta, sd=sqrt(prior_var_delta), log=TRUE) -
dnorm(delta_candidate, mean=prior_mean_delta, sd=sqrt(prior_var_delta), log=TRUE)
mu_candidate <- exp(design_matrix %*% beta_candidate)
nu_candidate <- rep(exp(-delta_candidate), length(y))
if (accept_move(y=y, mu_new=mu_candidate, nu_new=nu_candidate, mu=mu_current, nu=nu_current, log_u=log_u, ...)$accept) {
beta_current <- beta_candidate
delta_current <- delta_candidate
mu_current <- mu_candidate
nu_current <- nu_candidate
accept_mixed <- accept_mixed + 1 / p
}
}
# Beta update
beta_candidate <- drop(mvnfast::rmvn(1, mu=beta_current, sigma=update_cov$beta))
mu_candidate <- exp(design_matrix %*% beta_candidate)
nu_candidate <- nu_current
log_u <- log(runif(1)) + mvnfast::dmvn(beta_current, mu=prior_mean_beta, sigma=prior_var_beta, log=TRUE) -
mvnfast::dmvn(beta_candidate, mu=prior_mean_beta, sigma=prior_var_beta, log=TRUE)
if (accept_move(y=y, mu_new=mu_candidate, nu_new=nu_candidate, mu=mu_current, nu=nu_current, log_u=log_u, ...)$accept) {
beta_current <- beta_candidate
mu_current <- mu_candidate
accept_beta <- accept_beta + 1
}
# Delta update (scalar)
delta_candidate <- rnorm(1, mean=delta_current, sd=sqrt(update_cov$delta))
nu_candidate <- rep(exp(-delta_candidate), length(y))
log_u <- log(runif(1)) +
dnorm(delta_current, mean=prior_mean_delta, sd=sqrt(prior_var_delta), log=TRUE) -
dnorm(delta_candidate, mean=prior_mean_delta, sd=sqrt(prior_var_delta), log=TRUE)
if (accept_move(y=y, mu_new=mu_current, nu_new=nu_candidate, mu=mu_current, nu=nu_current, log_u=log_u, ...)$accept) {
delta_current <- delta_candidate
nu_current <- nu_candidate
accept_delta <- accept_delta + 1
}
utils::setTxtProgressBar(pb, l)
posterior_beta[l,] <- beta_current
posterior_delta[l] <- delta_current
}
close(pb)
list(
posterior_beta = posterior_beta[-(1:burnin), ],
posterior_delta = posterior_delta[-(1:burnin)],
accept_beta = accept_beta / (burnin + num_samples),
accept_delta = accept_delta / (burnin + num_samples),
accept_mixed = accept_mixed / (burnin + num_samples)
)
}
# Load data from library Rchoice
library(Rchoice)
data(Articles)
# Focusing only on the students with at least one publication
phdpublish <- subset(Articles, art>0)
phdpublish <- transform(phdpublish, art=art-1)
# Standardise all non-binary covariates
phdpublish <- cbind(phdpublish[,c(1,2,3)],scale(phdpublish[,-c(1,2,3)],center=TRUE,scale=TRUE))
result <- cmpoisreg_scalar_delta(
y = phdpublish$art,
X = phdpublish[, 2:6],
num_samples = 1e4,
burnin = 1e3,
prior_var_beta = diag(6),
prior_var_delta = 1
)
cmpoisreg_scalar_delta <- function(y, X, num_samples, burnin,
algorithm="exchange", empirical_cov,
update_emp_cov_cycle=1e3, update_scaling=2,
initial_beta, initial_delta,
prior_mean_beta, prior_var_beta,
prior_mean_delta, prior_var_delta,
random_seed, ...) {
conditional_var <- function(S, idx) {
S[idx,idx]-S[idx,-idx]%*%solve(S[-idx,-idx])%*%S[-idx,idx]
}
accept_move_exchange <- function(y, mu_new, nu_new, mu, nu, log_u, ...) {
ystar <- rcmpois(mu=mu_new, nu=nu_new, n=1)
log_likeli_ratio <- sum(dcmpois(y, mu=mu_new, nu=nu_new, log=TRUE, unnormalised=TRUE) -
dcmpois(y, mu=mu, nu=nu, log=TRUE, unnormalised=TRUE)) +
sum(-dcmpois(ystar, mu=mu_new, nu=nu_new, log=TRUE, unnormalised=TRUE) +
dcmpois(ystar, mu=mu, nu=nu, log=TRUE, unnormalised=TRUE))
list(accept = log_likeli_ratio > log_u, details = list())
}
accept_move_bounds <- function(y, mu_new, nu_new, mu, nu, log_u, ...) {
control <- list(...)
log_rhs <- -log_u + sum(dcmpois(y, mu=mu_new, nu=nu_new, log=TRUE, unnormalised=TRUE) -
dcmpois(y, mu=mu, nu=nu, log=TRUE, unnormalised=TRUE))
comlog_new <- NULL
comlog <- NULL
iterations <- control$iterations
while(TRUE) {
comlog_new <- logzcmpois(mu=mu_new, nu=nu_new, max.iter=iterations)
comlog <- logzcmpois(mu=mu, nu=nu, max.iter=iterations)
low_new <- sum(attr(comlog_new,"details")[,"lower"])
high_new <- sum(attr(comlog_new,"details")[,"upper"])
low <- sum(attr(comlog,"details")[,"lower"])
high <- sum(attr(comlog,"details")[,"upper"])
if (low_new - high > log_rhs) { accept <- FALSE; break }
if (high_new - low < log_rhs) { accept <- TRUE; break }
iterations <- iterations * control$iterations.multiplier
}
list(accept = accept, details = list())
}
accept_move <- c(accept_move_exchange, accept_move_bounds)[[pmatch(algorithm, c("exchange","bounds"))]]
# Add intercept to design matrix
design_matrix <- as.matrix(cbind(1, X))
p <- ncol(design_matrix)
# Priors
if (missing(prior_mean_beta))  prior_mean_beta <- rep(0, p)
if (missing(prior_var_beta))   prior_var_beta <- diag(p) * 100
if (missing(prior_mean_delta)) prior_mean_delta <- 0       # scalar
if (missing(prior_var_delta))  prior_var_delta <- 100       # scalar
# Initial values
if (missing(initial_beta) || missing(initial_delta) || missing(empirical_cov))
freq_glm <- stats::glm(y ~ design_matrix - 1, family="quasipoisson")
if (missing(initial_beta)) initial_beta <- stats::coef(freq_glm)
if (missing(initial_delta)) initial_delta <- log(summary(freq_glm)$dispersion)
update_empirical_cov <- FALSE
if (missing(empirical_cov)) {
empirical_cov <- diag(p) * summary(freq_glm)$cov.scaled[1,1]  # simple scaled identity
update_empirical_cov <- TRUE
}
generate_updates <- function(empirical_cov) {
# Mixed updates for beta only
sel <- 1:p
mixed <- list()
for (i in sel) {
mixed[[i]] <- conditional_var(empirical_cov, i) * update_scaling^2
}
# Beta proposal variance
beta_var <- conditional_var(empirical_cov, 1:p) * update_scaling^2
# Delta is scalar â†’ just use the prior empirical covariance times scaling
delta_var <- if(length(empirical_cov) == 1) {
empirical_cov * update_scaling^2
} else {
prior_var_delta * update_scaling^2  # fallback
}
list(
beta = beta_var,
delta = delta_var,
mixed = mixed
)
}
update_cov <- generate_updates(empirical_cov)
if (!missing(random_seed)) set.seed(random_seed)
# Current values
beta_current <- drop(mvnfast::rmvn(1, mu=initial_beta, sigma=empirical_cov[1:p,1:p]))
delta_current <- initial_delta  # scalar
mu_current <- exp(design_matrix %*% beta_current)
nu_current <- rep(exp(-delta_current), length(y))  # broadcast scalar
pb <- utils::txtProgressBar(min=1, max=num_samples, style=3)
accept_beta <- 0
accept_delta <- 0
accept_mixed <- 0
posterior_beta <- matrix(0, nrow=num_samples+burnin, ncol=p)
posterior_delta <- numeric(num_samples+burnin)
for (l in 1:(num_samples+burnin)) {
if ((l == burnin || (l < burnin && l %% update_emp_cov_cycle == 0)) && update_empirical_cov) {
empirical_cov <- stats::var(posterior_beta)
update_cov <- generate_updates(empirical_cov)
}
# Mixed updates
for (i in 1:p) {
par_candidate <- drop(mvnfast::rmvn(1, mu=c(beta_current[i], delta_current), sigma=diag(c(update_cov$mixed[[i]], update_cov$delta))))
beta_candidate <- beta_current; beta_candidate[i] <- par_candidate[1]
delta_candidate <- par_candidate[2]  # scalar
log_u <- log(runif(1)) +
mvnfast::dmvn(beta_current, mu=prior_mean_beta, sigma=prior_var_beta, log=TRUE) -
mvnfast::dmvn(beta_candidate, mu=prior_mean_beta, sigma=prior_var_beta, log=TRUE) +
dnorm(delta_current, mean=prior_mean_delta, sd=sqrt(prior_var_delta), log=TRUE) -
dnorm(delta_candidate, mean=prior_mean_delta, sd=sqrt(prior_var_delta), log=TRUE)
mu_candidate <- exp(design_matrix %*% beta_candidate)
nu_candidate <- rep(exp(-delta_candidate), length(y))
if (accept_move(y=y, mu_new=mu_candidate, nu_new=nu_candidate, mu=mu_current, nu=nu_current, log_u=log_u, ...)$accept) {
beta_current <- beta_candidate
delta_current <- delta_candidate
mu_current <- mu_candidate
nu_current <- nu_candidate
accept_mixed <- accept_mixed + 1 / p
}
}
# Beta update
beta_candidate <- drop(mvnfast::rmvn(1, mu=beta_current, sigma=update_cov$beta))
mu_candidate <- exp(design_matrix %*% beta_candidate)
nu_candidate <- nu_current
log_u <- log(runif(1)) + mvnfast::dmvn(beta_current, mu=prior_mean_beta, sigma=prior_var_beta, log=TRUE) -
mvnfast::dmvn(beta_candidate, mu=prior_mean_beta, sigma=prior_var_beta, log=TRUE)
if (accept_move(y=y, mu_new=mu_candidate, nu_new=nu_candidate, mu=mu_current, nu=nu_current, log_u=log_u, ...)$accept) {
beta_current <- beta_candidate
mu_current <- mu_candidate
accept_beta <- accept_beta + 1
}
# Delta update (scalar)
delta_candidate <- rnorm(1, mean=delta_current, sd=sqrt(update_cov$delta))
nu_candidate <- rep(exp(-delta_candidate), length(y))
log_u <- log(runif(1)) +
dnorm(delta_current, mean=prior_mean_delta, sd=sqrt(prior_var_delta), log=TRUE) -
dnorm(delta_candidate, mean=prior_mean_delta, sd=sqrt(prior_var_delta), log=TRUE)
if (accept_move(y=y, mu_new=mu_current, nu_new=nu_candidate, mu=mu_current, nu=nu_current, log_u=log_u, ...)$accept) {
delta_current <- delta_candidate
nu_current <- nu_candidate
accept_delta <- accept_delta + 1
}
utils::setTxtProgressBar(pb, l)
posterior_beta[l,] <- beta_current
posterior_delta[l] <- delta_current
}
close(pb)
list(
posterior_beta = posterior_beta[-(1:burnin), ],
posterior_delta = posterior_delta[-(1:burnin)],
accept_beta = accept_beta / (burnin + num_samples),
accept_delta = accept_delta / (burnin + num_samples),
accept_mixed = accept_mixed / (burnin + num_samples)
)
}
# Load data from library Rchoice
library(Rchoice)
data(Articles)
# Focusing only on the students with at least one publication
phdpublish <- subset(Articles, art>0)
phdpublish <- transform(phdpublish, art=art-1)
# Standardise all non-binary covariates
phdpublish <- cbind(phdpublish[,c(1,2,3)],scale(phdpublish[,-c(1,2,3)],center=TRUE,scale=TRUE))
result <- cmpoisreg_scalar_delta(
y = phdpublish$art,
X = phdpublish[, 2:6],
num_samples = 1e4,
burnin = 1e3,
prior_var_beta = diag(6),
prior_var_delta = 1
)
cmpoisreg_scalar_delta <- function(
y, X, num_samples, burnin,
algorithm = "exchange",
empirical_cov, update_emp_cov_cycle = 1e3,
update_scaling = 2,
initial_beta, initial_delta,
prior_mean_beta, prior_var_beta,
prior_mean_delta, prior_var_delta,
random_seed, ...
) {
conditional_var <- function(S, idx) {
S[idx, idx] - S[idx, -idx] %*% solve(S[-idx, -idx]) %*% S[-idx, idx]
}
accept_move_exchange <- function(y, mu_new, nu_new, mu, nu, log_u, ...) {
ystar <- rcmpois(mu = mu_new, nu = nu_new, n = 1)
log_likeli_ratio <- sum(
dcmpois(y, mu = mu_new, nu = nu_new, log = TRUE, unnormalised = TRUE) -
dcmpois(y, mu = mu, nu = nu, log = TRUE, unnormalised = TRUE)
) +
sum(
-dcmpois(ystar, mu = mu_new, nu = nu_new, log = TRUE, unnormalised = TRUE) +
dcmpois(ystar, mu = mu, nu = nu, log = TRUE, unnormalised = TRUE)
)
list(accept = log_likeli_ratio > log_u, details = list())
}
accept_move_bounds <- function(y, mu_new, nu_new, mu, nu, log_u, ...) {
control <- list(...)
log_rhs <- -log_u + sum(
dcmpois(y, mu = mu_new, nu = nu_new, log = TRUE, unnormalised = TRUE) -
dcmpois(y, mu = mu, nu = nu, log = TRUE, unnormalised = TRUE)
)
comlog_new <- NULL
comlog <- NULL
iterations <- control$iterations
while (TRUE) {
comlog_new <- logzcmpois(mu = mu_new, nu = nu_new, max.iter = iterations)
comlog <- logzcmpois(mu = mu, nu = nu, max.iter = iterations)
low_new <- sum(attr(comlog_new, "details")[, "lower"])
high_new <- sum(attr(comlog_new, "details")[, "upper"])
low <- sum(attr(comlog, "details")[, "lower"])
high <- sum(attr(comlog, "details")[, "upper"])
if (low_new - high > log_rhs) { accept <- FALSE; break }
if (high_new - low < log_rhs) { accept <- TRUE; break }
iterations <- iterations * control$iterations.multiplier
}
list(accept = accept, details = list())
}
accept_move <- c(accept_move_exchange, accept_move_bounds)[[pmatch(algorithm, c("exchange", "bounds"))]]
design_matrix <- as.matrix(cbind(1, X))
p <- ncol(design_matrix)
# Priors
if (missing(prior_mean_beta)) prior_mean_beta <- rep(0, p)
if (missing(prior_var_beta)) prior_var_beta <- diag(p) * 100
if (missing(prior_mean_delta)) prior_mean_delta <- 0
if (missing(prior_var_delta)) prior_var_delta <- 100
if (missing(initial_beta) || missing(initial_delta) || missing(empirical_cov))
freq_glm <- stats::glm(y ~ design_matrix - 1, family = "quasipoisson")
if (missing(initial_beta)) initial_beta <- stats::coef(freq_glm)
if (missing(initial_delta)) initial_delta <- log(summary(freq_glm)$dispersion)
if (missing(empirical_cov)) {
empirical_cov <- summary(freq_glm)$cov.scaled
update_empirical_cov <- TRUE
} else {
update_empirical_cov <- FALSE
}
generate_updates <- function(empirical_cov) {
mixed <- list()
for (i in 1:p) {
mixed[[i]] <- conditional_var(empirical_cov, i) * update_scaling^2
}
list(
beta = conditional_var(empirical_cov, 1:p) * update_scaling^2,
delta = prior_var_delta * update_scaling^2,
mixed = mixed
)
}
update_cov <- generate_updates(empirical_cov)
if (!missing(random_seed)) set.seed(random_seed)
beta_current <- drop(mvnfast::rmvn(1, mu = initial_beta, sigma = empirical_cov))
delta_current <- initial_delta
mu_current <- exp(design_matrix %*% beta_current)
nu_current <- exp(-delta_current)
pb <- utils::txtProgressBar(min = 1, max = num_samples, style = 3)
accept_beta <- 0
accept_delta <- 0
accept_mixed <- 0
posterior_beta <- matrix(0, nrow = num_samples + burnin, ncol = p)
posterior_delta <- numeric(num_samples + burnin)
for (l in 1:(num_samples + burnin)) {
# Update beta mixed
if ((l == burnin || (l < burnin && l %% update_emp_cov_cycle == 0)) && update_empirical_cov) {
empirical_cov <- stats::var(posterior_beta)
update_cov <- generate_updates(empirical_cov)
}
for (i in 1:p) {
par_candidate <- drop(mvnfast::rmvn(1, mu = c(beta_current[i], delta_current), sigma = diag(c(update_cov$mixed[[i]], update_cov$delta))))
beta_candidate <- beta_current
beta_candidate[i] <- par_candidate[1]
delta_candidate <- par_candidate[2]
mu_candidate <- exp(design_matrix %*% beta_candidate)
nu_candidate <- exp(-delta_candidate)
log_u <- log(stats::runif(1)) +
mvnfast::dmvn(beta_current, mu = prior_mean_beta, sigma = prior_var_beta, log = TRUE) -
mvnfast::dmvn(beta_candidate, mu = prior_mean_beta, sigma = prior_var_beta, log = TRUE)
if (accept_move(y = y, mu_new = mu_candidate, nu_new = nu_candidate,
mu = mu_current, nu = nu_current, log_u = log_u, ...)$accept) {
beta_current <- beta_candidate
mu_current <- mu_candidate
delta_current <- delta_candidate
nu_current <- nu_candidate
accept_mixed <- accept_mixed + 1 / p
}
}
# Update beta multivariate
beta_candidate <- drop(mvnfast::rmvn(1, mu = beta_current, sigma = update_cov$beta))
mu_candidate <- exp(design_matrix %*% beta_candidate)
log_u <- log(stats::runif(1)) +
mvnfast::dmvn(beta_current, mu = prior_mean_beta, sigma = prior_var_beta, log = TRUE) -
mvnfast::dmvn(beta_candidate, mu = prior_mean_beta, sigma = prior_var_beta, log = TRUE)
if (accept_move(y = y, mu_new = mu_candidate, nu_new = nu_current,
mu = mu_current, nu = nu_current, log_u = log_u, ...)$accept) {
beta_current <- beta_candidate
mu_current <- mu_candidate
accept_beta <- accept_beta + 1
}
# Update delta (scalar)
delta_candidate <- rnorm(1, mean = delta_current, sd = sqrt(update_cov$delta))
nu_candidate <- exp(-delta_candidate)
log_u <- log(stats::runif(1)) +
dnorm(delta_current, mean = prior_mean_delta, sd = sqrt(prior_var_delta), log = TRUE) -
dnorm(delta_candidate, mean = prior_mean_delta, sd = sqrt(prior_var_delta), log = TRUE)
if (accept_move(y = y, mu_new = mu_current, nu_new = nu_candidate,
mu = mu_current, nu = nu_current, log_u = log_u, ...)$accept) {
delta_current <- delta_candidate
nu_current <- nu_candidate
accept_delta <- accept_delta + 1
}
utils::setTxtProgressBar(pb, l)
posterior_beta[l, ] <- beta_current
posterior_delta[l] <- delta_current
}
close(pb)
list(
posterior_beta = posterior_beta[-(1:burnin), ],
posterior_delta = posterior_delta[-(1:burnin)],
accept_beta = accept_beta / (burnin + num_samples),
accept_delta = accept_delta / (burnin + num_samples),
accept_mixed = accept_mixed / (burnin + num_samples)
)
}
# Load data from library Rchoice
library(Rchoice)
data(Articles)
# Focusing only on the students with at least one publication
phdpublish <- subset(Articles, art>0)
phdpublish <- transform(phdpublish, art=art-1)
# Standardise all non-binary covariates
phdpublish <- cbind(phdpublish[,c(1,2,3)],scale(phdpublish[,-c(1,2,3)],center=TRUE,scale=TRUE))
result <- cmpoisreg_scalar_delta(
y = phdpublish$art,
X = phdpublish[, 2:6],
num_samples = 1e4,
burnin = 1e3,
prior_var_beta = diag(6),
prior_var_delta = 1
)
knitr::opts_chunk$set(echo = TRUE)
remove.packages("combayes")
setwd("/Users/jimmy/Desktop/OrderStats/models/flights_final/combayes-master")
install.packages(".", repos = NULL, type = "source")
library(combayes)
# Load data from library Rchoice
# Load data from library Rchoice
library(Rchoice)
data(Articles)
# Focusing only on the students with at least one publication
phdpublish <- subset(Articles, art>0)
phdpublish <- transform(phdpublish, art=art-1)
# Standardise all non-binary covariates
phdpublish <- cbind(phdpublish[,c(1,2,3)],scale(phdpublish[,-c(1,2,3)],center=TRUE,scale=TRUE))
result <- cmpoisreg(y=phdpublish$art, X=phdpublish[,2:6], num_samples=1e4, burnin=1e3,prior_var_beta=diag(6),prior_var_delta=diag(6))
# Load data from library Rchoice
# Load data from library Rchoice
library(Rchoice)
data(Articles)
# Focusing only on the students with at least one publication
phdpublish <- subset(Articles, art>0)
phdpublish <- transform(phdpublish, art=art-1)
# Standardise all non-binary covariates
phdpublish <- cbind(phdpublish[,c(1,2,3)],scale(phdpublish[,-c(1,2,3)],center=TRUE,scale=TRUE))
result <- cmpoisreg(y=phdpublish$art, X=phdpublish[,2:6], num_samples=1e4, burnin=1e3,prior_var_beta=diag(6))
# Load data from library Rchoice
# Load data from library Rchoice
library(Rchoice)
data(Articles)
# Focusing only on the students with at least one publication
phdpublish <- subset(Articles, art>0)
phdpublish <- transform(phdpublish, art=art-1)
# Standardise all non-binary covariates
phdpublish <- cbind(phdpublish[,c(1,2,3)],scale(phdpublish[,-c(1,2,3)],center=TRUE,scale=TRUE))
result <- cmpoisreg(y=phdpublish$art, X=phdpublish[,2:6], num_samples=1e4, burnin=1e3,prior_var_beta=diag(6))
remove.packages("combayes")
setwd("/Users/jimmy/Desktop/OrderStats/models/flights_final/combayes-master")
install.packages(".", repos = NULL, type = "source")
library(combayes)
remove.packages("combayes")
setwd("/Users/jimmy/Desktop/OrderStats/models/flights_final/combayes-master")
install.packages(".", repos = NULL, type = "source")
library(combayes)
# Load data from library Rchoice
# Load data from library Rchoice
library(Rchoice)
data(Articles)
# Focusing only on the students with at least one publication
phdpublish <- subset(Articles, art>0)
phdpublish <- transform(phdpublish, art=art-1)
# Standardise all non-binary covariates
phdpublish <- cbind(phdpublish[,c(1,2,3)],scale(phdpublish[,-c(1,2,3)],center=TRUE,scale=TRUE))
result <- cmpoisreg(y=phdpublish$art, X=phdpublish[,2:6], num_samples=1e4, burnin=1e3,prior_var_beta=diag(6))
knitr::opts_chunk$set(echo = TRUE)
remove.packages("combayes")
setwd("/Users/jimmy/Desktop/OrderStats/models/flights_final/combayes-master")
install.packages(".", repos = NULL, type = "source")
library(combayes)
# Load data from library Rchoice
# Load data from library Rchoice
library(Rchoice)
data(Articles)
# Focusing only on the students with at least one publication
phdpublish <- subset(Articles, art>0)
phdpublish <- transform(phdpublish, art=art-1)
# Standardise all non-binary covariates
phdpublish <- cbind(phdpublish[,c(1,2,3)],scale(phdpublish[,-c(1,2,3)],center=TRUE,scale=TRUE))
result <- cmpoisreg(y=phdpublish$art, X=phdpublish[,2:6], num_samples=1e4, burnin=1e3,prior_var_beta=diag(6))
# Load data from library Rchoice
# Load data from library Rchoice
library(Rchoice)
data(Articles)
# Focusing only on the students with at least one publication
phdpublish <- subset(Articles, art>0)
phdpublish <- transform(phdpublish, art=art-1)
# Standardise all non-binary covariates
phdpublish <- cbind(phdpublish[,c(1,2,3)],scale(phdpublish[,-c(1,2,3)],center=TRUE,scale=TRUE))
result <- cmpoisreg(y=phdpublish$art, X=phdpublish[,2:6], num_samples=1e4, burnin=1e3,
prior_var_beta=diag(6),
prior_var_delta = 1,
prior_mean_delta = 0)
# Load data from library Rchoice
# Load data from library Rchoice
library(Rchoice)
data(Articles)
# Focusing only on the students with at least one publication
phdpublish <- subset(Articles, art>0)
phdpublish <- transform(phdpublish, art=art-1)
# Standardise all non-binary covariates
phdpublish <- cbind(phdpublish[,c(1,2,3)],scale(phdpublish[,-c(1,2,3)],center=TRUE,scale=TRUE))
result <- cmpoisreg(y=phdpublish$art, X=phdpublish[,2:6], num_samples=1e4, burnin=1e3,
prior_var_beta=diag(6),
prior_var_delta = diag(1),
prior_mean_delta = rep(0,1))
source("~/Desktop/OrderStats/models/flights_final/combayes-master/R/cmpoisreg.R", echo=TRUE)
remove.packages("combayes")
setwd("/Users/jimmy/Desktop/OrderStats/models/flights_final/combayes-master")
install.packages(".", repos = NULL, type = "source")
library(combayes)
# Load data from library Rchoice
# Load data from library Rchoice
library(Rchoice)
data(Articles)
# Focusing only on the students with at least one publication
phdpublish <- subset(Articles, art>0)
phdpublish <- transform(phdpublish, art=art-1)
# Standardise all non-binary covariates
phdpublish <- cbind(phdpublish[,c(1,2,3)],scale(phdpublish[,-c(1,2,3)],center=TRUE,scale=TRUE))
result <- cmpoisreg(y=phdpublish$art, X=phdpublish[,2:6], num_samples=1e4, burnin=1e3,
prior_var_beta=diag(6),
prior_var_delta = diag(1),
prior_mean_delta = rep(0,1))
